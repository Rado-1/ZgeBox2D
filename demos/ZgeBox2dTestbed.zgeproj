<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Comment="ZgeBox2D Testbed, v0.92. Created by Radovan Cervenka" Caption="ZgeBox2D Testbed" ClearColor="0 0 0 1" ScreenMode="0" CameraPosition="0 0 22" LightPosition="5 -10 7.3" ViewportRatio="3" MouseVisible="255" FileVersion="2" AndroidPackageName="com.rado1.ZgeBox2dTestbed" AndroidVersionName="0.91">
  <OnLoaded>
    <ZExternalLibrary Comment="Box2D physics library" ModuleName="ZgeBox2D" CallingConvention="1" BeforeInitExp="if(ANDROID) this.ModuleName = &quot;./libZgeBox2D.so&quot;;">
      <Source>
<![CDATA[/*
  Adapter to the ZgeBox2D Library, a wrapper for the Box2D Physics Engine.
  http://box2d.org/

  Download Windows DLL and Android shared library from
  https://github.com/Rado-1/ZgeBox2D/releases

  Project home
  https://github.com/Rado-1/ZgeBox2D

  Copyright (c) 2013-2016 Radovan Cervenka

  Version: 1.0 (2016-10-27)

  */

// Constants

// type of body
const int
  ZB2_STATIC = 0,
  ZB2_KINEMATIC = 1,
  ZB2_DYNAMIC = 2;

// state of contact point
const int
  ZB2_NULL_STATE = 0,    // point does not exist
  ZB2_ADD_STATE = 1,     // point was added in the update
  ZB2_PERSIST_STATE = 2, // point persisted across the update
  ZB2_REMOVE_STATE = 3;  // point was removed in the update

// World

// init
void zb2InitWorld(float gravityX, float gravityY) {}

// destroy
void zb2DestroyWorld() {}

// allow/suppress global collision detection
void zb2AllowCollisionDetection(int allow) {}

// advance simulation
void zb2Step(float timeStep, int velocityIterations, int positionIterations) {}

// clear forces
void zb2ClearForces() {}

// allow/suppress sleeping of inactive bodies
void zb2SetAllowSleeping(int allow) {}

// set gravity
void zb2SetGravity(float x, float y) {}

// enable/disable warm starting; for testing
void zb2SetWarmStarting(int enable) {}

// count bodies
int zb2GetBodyCount() {}

void zb2DestroyAllBodies() {}

// Bodies

// create and return a static body without shape
xptr zb2CreateEmptyBody(float x, float y, int type) {}

// create and return box
xptr zb2CreateBox(float x, float y, float width, float height, float angle, int type) {}

// create and return circle
xptr zb2CreateCircle(float x, float y, float radius, int type) {}

// create and return polygon (up to 8 vertices)
// vertices - 2D array of floats or 1D array of vec2
xptr zb2CreatePolygon(float x, float y, xptr vertices, int count, float angle, int type) {}

// create and return static edge
xptr zb2CreateEdge(float x1, float y1, float x2, float y2) {}

// create and return static chain
// vertices - 2D array of floats or 1D array of vec2
xptr zb2CreateChain(xptr vertices, int count, int isLoop) {}

// compound bodies

// add box to existing body
void zb2AddBox(xptr body, float x, float y, float width, float height,
  float angle) {}

// add circle to existing body
void zb2AddCircle(xptr body, float x, float y, float radius) {}

// add polygon to existing body
// vertices - 2D array of floats or 1D array of vec2
void zb2AddPolygon(xptr body, xptr vertices, int count) {}

// add edge to existing body
void zb2AddEdge(xptr body, float x1, float y1, float x2, float y2) {}

// add chain to existing body
// vertices - 2D array of floats or 1D array of vec2
void zb2AddChain(xptr body, xptr vertices, int count, int isLoop) {}

// destroy body
void zb2DestroyBody(xptr body) {}

// getters
float zb2GetPositionX(xptr body) {}
float zb2GetPositionY(xptr body) {}
float zb2GetAngle(xptr body) {}
void zb2GetTransform(xptr body, ref float x, ref float y, ref float angle) {}
float zb2GetMass(xptr body) {}
int zb2IsAwake(xptr body) {}

// setters
void zb2SetPosition(xptr body, float x, float y) {}
void zb2SetRotation(xptr body, float angle) {}
void zb2SetTransform(xptr body, float x, float y, float angle) {}
void zb2SetLinearVelocity(xptr body, float x, float y) {}
void zb2SetAngularVelocity(xptr body, float omega) {}
void zb2SetLinearDamping(xptr body, float linearDamping) {}
void zb2SetAngularDamping(xptr body, float angularDamping) {}
void zb2SetDensity(xptr body, float density) {}
void zb2SetFriction(xptr body, float friction) {} // can be more than 1.0
void zb2SetRestitution(xptr body, float restitution) {}
void zb2SetGravityScale(xptr body, float gravityScale) {} // -1.0 - reverse gravity
void zb2SetFixedRotation(xptr body, int hasFixedRotation) {}
void zb2SetSleepingAllowed(xptr body, int isSleepingAllowed) {}
void zb2SetBullet(xptr body, int isBullet) {}
void zb2SetSensor(xptr body, int isSensor) {}
void zb2SetActive(xptr body, int isActive) {}
void zb2SetMass(xptr body, float mass) {}
void zb2SetMassData(xptr body, float mass, float x, float y, float rotationalInertia) {}
void zb2ResetMassData(xptr body) {}

// apply forces
void zb2ApplyForce(xptr body, float forceX, float forceY, float pointX, float pointY, int wake) {}
void zb2ApplyForceToCenter(xptr body, float forceX, float forceY, int wake) {}
void zb2ApplyTorque(xptr body, float torque, int wake) {}
void zb2ApplyLinearImpulse(xptr body, float impulseX, float impulseY, float pointX, float pointY, int wake) {}
void zb2ApplyAngularImpulse(xptr body, float impulse, int wake) {}

// changing shapes
void zb2ChangeCircleRadius(xptr body, float radius) {}
void zb2ChangeEdge(xptr body, float x1, float y1, float x2, float y2) {}

// Joints

// create and return distance joint
// local coordinates used
xptr zb2CreateDistanceJoint(xptr bodyA, xptr bodyB,
	float anchorAx, float anchorAy, float anchorBx, float anchorBy, float length,
	float frequency, float dampingRatio, int isCollided) {}

// create and return distance joint
// world coordinates used
xptr zb2CreateDistanceJointWorld(xptr bodyA, xptr bodyB,
	float anchorAx, float anchorAy, float anchorBx, float anchorBy, float length,
	float frequency, float dampingRatio, int isCollided) {}

// update distance joint
void zb2UpdateDistanceJoint(xptr joint, float length,
	float frequency, float dampingRatio) {}

// create and return prismatic joint
// local coordinates used
xptr zb2CreatePrismaticJoint(xptr bodyA, xptr bodyB,
	float anchorAx, float anchorAy, float anchorBx, float anchorBy,
	float axisAx, float axisAy, float referenceAngle,
	int enableLimit, float lower, float upper,
	int enableMotor, float maxMotorForce, float motorSpeed, int isCollided) {}

// create and return prismatic joint
// world coordinates used
xptr zb2CreatePrismaticJointWorld(xptr bodyA, xptr bodyB,
	float anchorX, float anchorY, float axisX, float axisY,
	int enableLimit, float lower, float upper,
	int enableMotor, float maxMotorForce, float motorSpeed, int isCollided) {}

// update prismatic joint
void zb2UpdatePrismaticJoint(xptr joint,
	int enableLimit, float lower, float upper,
	int enableMotor, float maxMotorForce, float motorSpeed) {}

// get current translation of prismatic joint
float zb2GetPrismaticTranslation(xptr joint) {}

// get current speed of prismatic joint
float zb2GetPrismaticSpeed(xptr joint) {}

// create and return revolute joint
// local coordinates used
xptr zb2CreateRevoluteJoint(xptr bodyA, xptr bodyB,
	float anchorAx, float anchorAy, float anchorBx, float anchorBy,
	float referenceAngle, int enableLimit, float lowerAngle, float upperAngle,
	int enableMotor, float motorSpeed, float maxMotorTorque, int isCollided) {}

// create and return revolute joint
// world coordinates used
xptr zb2CreateRevoluteJointWorld(xptr bodyA, xptr bodyB,
	float anchorX, float anchorY, int enableLimit, float lowerAngle, float upperAngle,
	int enableMotor, float motorSpeed, float maxMotorTorque, int isCollided) {}

// update revolute joint
void zb2UpdateRevoluteJoint(xptr joint,
	int enableLimit, float lowerAngle, float upperAngle,
	int enableMotor, float motorSpeed, float maxMotorTorque) {}

// get current angle of revolute joint
float zb2GetRevoluteAngle(xptr joint) {}

// create and return weld joint
// local coordinates used
xptr zb2CreateWeldJoint(xptr bodyA, xptr bodyB,
	float anchorAx, float anchorAy, float anchorBx, float anchorBy,
	float referenceAngle, float frequency, float dampingRatio, int isCollided) {}

// create and return weld joint
// world coordinates used
xptr zb2CreateWeldJointWorld(xptr bodyA, xptr bodyB,
	float anchorX, float anchorY, float frequency, float dampingRatio,
	int isCollided) {}

// update weld joint
void zb2UpdateWeldJoint(xptr joint, float frequency, float dampingRatio) {}

// create and return rope joint
// local coordinates used
xptr zb2CreateRopeJoint(xptr bodyA, xptr bodyB,
	float anchorAx, float anchorAy, float anchorBx, float anchorBy,
	float maxLength, int isCollided) {}

// update rope joint
void zb2UpdateRopeJoint(xptr joint, float maxLength) {}

// create and return pulley joint
// local coordinates used
xptr zb2CreatePulleyJoint(xptr bodyA, xptr bodyB,
	float anchorAx, float anchorAy, float anchorBx, float anchorBy,
	float groundAx, float groundAy, float groundBx, float groundBy,
	float lengthA, float lengthB, float ratio, int isCollided) {}

// create and return pulley joint
// world coordinates used
xptr zb2CreatePulleyJointWorld(xptr bodyA, xptr bodyB,
	float anchorAx, float anchorAy, float anchorBx, float anchorBy,
	float groundAx, float groundAy, float groundBx, float groundBy,
	float ratio, int isCollided) {}

// get length of rope at side A of pulley joint
float zb2GetPulleyLengthA(xptr joint) {}

// get length of rope at side B of pulley joint
float zb2GetPulleyLengthB(xptr joint) {}

// create and return gear joint
// only revolute and/or prismatic joints can be connected
xptr zb2CreateGearJoint(xptr joint1, xptr joint2, float ratio, int isCollided) {}

// update gear joint
void zb2UpdateGearJoint(xptr joint, float ratio) {}

// create and return wheel joint
// local coordinates used
xptr zb2CreateWheelJoint(xptr bodyA, xptr bodyB,
	float anchorAx, float anchorAy, float anchorBx, float anchorBy,
	float axisAx, float axisAy,
	int enableMotor, float motorSpeed, float maxMotorTorque,
	float frequency, float dampingRatio, int isCollided) {}

// create and return wheel joint
// world coordinates used
xptr zb2CreateWheelJointWorld(xptr bodyA, xptr bodyB,
	float anchorX, float anchorY,float axisX, float axisY,
	int enableMotor, float motorSpeed, float maxMotorTorque,
	float frequency, float dampingRatio, int isCollided) {}

// update wheel joint
void zb2UpdateWheelJoint(xptr joint, int enableMotor,
	float motorSpeed, float maxMotorTorque,
	float frequency, float dampingRatio) {}

// get wheel joint's spring translation
float zb2GetWheelTranslation(xptr joint) {}

// get wheel's angle
float zb2GetWheelAngle(xptr joint) {}

// get wheel joint's spring translation speed
float zb2GetWheelLinearSpeed(xptr joint) {}

// get wheel's angular speed
float zb2GetWheelAngularSpeed(xptr joint) {}

// create and return motor joint
// local coordinates used
xptr zb2CreateMotorJoint(xptr bodyA, xptr bodyB,
	float linearOffsetX, float linearOffsetY, float angularOffset,
	float maxForce, float maxTorque, float correctionFactor, int isCollided) {}

// create and return motor joint
// world coordinates used
xptr zb2CreateMotorJointWorld(xptr bodyA, xptr bodyB,
	float maxForce, float maxTorque, float correctionFactor, int isCollided) {}

// update motor joint
void zb2UpdateMotorJoint(xptr joint,
	float linearOffsetX, float linearOffsetY, float angularOffset,
	float maxForce, float maxTorque, float correctionFactor) {}

// create and return mouse joint
// world coordinates used
xptr zb2CreateMouseJoint(xptr body, float targetX, float targetY,
	float maxForce,	float frequency, float dampingRatio) {}

// update target of mouse joint
void zb2UpdateMouseJoint(xptr joint, float targetX, float targetY) {}

// destroy joint
void zb2DestroyJoint(xptr joint) {}

// get all joints of a body
// jointList - array of integers (1D) having sufficient size
void zb2GetJoints(xptr body, xptr jointList, ref int count) {}

// Custom user data

// set ZGE models
void zb2SetUserModelToBody(xptr body, model userModel) {}
void zb2SetUserModelToJoint(xptr joint, model userModel) {}

// get ZGE models
model zb2GetUserModelFromBody(xptr body) {}
model zb2GetUserModelFromJoint(xptr joint) {}

// Queries

// test containment of point in body
int zb2TestPoint(xptr body, float x, float y) {}

// get body at point or 0 if no body is there
int zb2GetBodyAtPoint(float x, float y, ref xptr body) {}

// raycast
// returns found body or null if no body found
xptr zb2RayCast(float x1, float y1, float x2, float y2,
	ref float x, ref float y, ref float normalX, ref float normalY) {}

// Collisions

// initialize getting of global collision points
void zb2ResetContacts() {}

// get next global collision point
// returns:
//    1 - next collision point was returned
//    0 - no other collision point is available
int zb2GetNextContact(ref xptr bodyA, ref xptr bodyB,
  ref float posX, ref float posY,
	ref float normX, ref float normY,
  ref int state) {}

// number of global collision points
int zb2GetContactCount() {}

// is body collided?
int zb2IsCollided(xptr body) {}

// number of collisions of given body
int zb2GetBodyContactCount(xptr body) {}

// set collision filtering flags to body
void zb2SetBodyFilteringFlags(xptr body, int categoryBits, int maskBits, int groupIndex) {}]]>
      </Source>
    </ZExternalLibrary>
    <ZLibrary Comment="Globals">
      <Source>
<![CDATA[// CONSTANTS

// boolean
const int FALSE = 0;
const int TRUE = 1;

// vector axes
const int _X = 0;
const int _Y = 1;

// goniometric
const float PI2 = PI * 2;

// pointers
const int NONE = 0;

// application-specific
const float POSITION_RATIO = 9.0;

// body shape types
const int BOX_SHAPE = 0;
const int CIRCLE_SHAPE = 1;
const int HOUSE_SHAPE = 2;
const int COMPOUND_SHAPE = 3;
const int TUMBLER_SHAPE = 4;
const int EDGE_SHAPE = 100;
const int CHAIN_SHAPE = 101;

// joint types
const int DISTANCE_JOINT = 0;
const int ROPE_JOINT = 1;


// GLOBAL VARIABLES

float ScreenAspectRatio;
float PointerX, PointerY;
int IsMoveMode;
int IsTouched;
xptr PointerJoint;
model DraggedModel;
xptr[30] BodyJoints;
vec2[30] LineBodyVerticesDef;

// body construction setters
int BodyShape;
float BodyPositionX;
float BodyPositionY;
float BodyRotation;
float BodyScaleX;
float BodyScaleY;
float BodyScaleZ;
int BodyFixedRotation;

// joint construction setters
int JointType;
float JointLength;
float JointFrequency;
float JointDampingRatio;
int JointIsCollided;

// auxiliary variables for unused reference parameters of function calls
float UNUSED_F;
xptr UNUSET_PTR;

// FUNCTIONS

void removeBody(model body){
    int c;
    model m;

    // remove attached visible joints
    zb2GetJoints(body.BodyId, BodyJoints, c);
    for(int i = 0; i < c; ++i){
      m = zb2GetUserModelFromJoint(BodyJoints[i]);
      if(m != null) m.IsRemoved = TRUE;
    }
    @RemoveModel();
}

// to be used in OnRender section
void drawLine(float x1, float y1, float x2, float y2){
  float x = x2 - x1, y = y2 - y1;
  LineTransform.Translate.X = (x1 + x2) / 2;
  LineTransform.Translate.Y = (y1 + y2) / 2;
  LineTransform.Scale.X = sqrt(x*x + y*y);
  LineTransform.Rotate.Z = atan2(y, x) / PI2;
  @CallComponent(Component: LineTransform);
}

void enableMoveButton(int enable){
  if(enable){
    MoveColor.Color.R = 0.7;
    MoveColor.Color.G =
    MoveColor.Color.B = 0;
  } else {
    MoveColor.Color.R = 0;
    MoveColor.Color.G = 0.25;
    MoveColor.Color.B = 0.5;
  }
}

void enableDeleteButton(int enable){
  if(enable){
    DeleteColor.Color.R = 0.7;
    DeleteColor.Color.G =
    DeleteColor.Color.B = 0;
  } else {
    DeleteColor.Color.R = 0;
    DeleteColor.Color.G = 0.25;
    DeleteColor.Color.B = 0.5;
  }
}

void enableScene1Button(int enable){
  if(enable){
    Scene1Color.Color.R = 0.7;
    Scene1Color.Color.G =
    Scene1Color.Color.B = 0;
  } else {
    Scene1Color.Color.R = 0;
    Scene1Color.Color.G = 0.25;
    Scene1Color.Color.B = 0.5;
  }
}

void enableScene2Button(int enable){
  if(enable){
    Scene2Color.Color.R = 0.7;
    Scene2Color.Color.G =
    Scene2Color.Color.B = 0;
  } else {
    Scene2Color.Color.R = 0;
    Scene2Color.Color.G = 0.25;
    Scene2Color.Color.B = 0.5;
  }
}

void enableScene3Button(int enable){
  if(enable){
    Scene3Color.Color.R = 0.7;
    Scene3Color.Color.G =
    Scene3Color.Color.B = 0;
  } else {
    Scene3Color.Color.R = 0;
    Scene3Color.Color.G = 0.25;
    Scene3Color.Color.B = 0.5;
  }
}

void enableScene4Button(int enable){
  if(enable){
    Scene4Color.Color.R = 0.7;
    Scene4Color.Color.G =
    Scene4Color.Color.B = 0;
  } else {
    Scene4Color.Color.R = 0;
    Scene4Color.Color.G = 0.25;
    Scene4Color.Color.B = 0.5;
  }
}]]>
      </Source>
    </ZLibrary>
    <ZExpression Comment="Init">
      <Expression>
<![CDATA[// init application variables
ScreenAspectRatio = 1.0 * App.ViewportWidth / App.ViewportHeight;
IsMoveMode = TRUE;
enableMoveButton(TRUE);
enableDeleteButton(FALSE);
enableScene1Button(TRUE);
enableScene2Button(FALSE);
enableScene3Button(FALSE);
enableScene4Button(FALSE);
PointerJoint = null;
DraggedModel = null;

// init simulation world
zb2InitWorld(0.0, -10.0);
zb2SetAllowSleeping(TRUE);
zb2AllowCollisionDetection(TRUE);]]>
      </Expression>
    </ZExpression>
    <SpawnModel Model="VisualizeCollisionModel" SpawnStyle="1"/>
    <SetAppState State="ShapesScene"/>
  </OnLoaded>
  <States>
    <AppState Name="ShapesScene" CollisionsEnabled="0">
      <OnStart>
        <ZExpression Comment="Init">
          <Expression>
<![CDATA[model m;

// reset spawning timer
SpawnTimer.CurrentRelativeTime = SpawnTimer.Interval;

// bowl
BodyShape = CHAIN_SHAPE;
LineBodyIsLoop = FALSE;
LineBodyVerticesDef[0][_X] = -7;
LineBodyVerticesDef[0][_Y] = -6;
LineBodyVerticesDef[1][_X] = -5;
LineBodyVerticesDef[1][_Y] = -8;
LineBodyVerticesDef[2][_X] = 0;
LineBodyVerticesDef[2][_Y] = -9;
LineBodyVerticesDef[3][_X] = 5;
LineBodyVerticesDef[3][_Y] = -8;
LineBodyVerticesDef[4][_X] = 7;
LineBodyVerticesDef[4][_Y] = -6;
LineBodyCount = 5;
createModel(LineBodyModel);

// barriers
LineBodyIsLoop = TRUE;
LineBodyVerticesDef[0][_X] = -5;
LineBodyVerticesDef[0][_Y] = 4;
LineBodyVerticesDef[1][_X] = -1.5;
LineBodyVerticesDef[1][_Y] = 6;
LineBodyVerticesDef[2][_X] = -1.5;
LineBodyVerticesDef[2][_Y] = 4;
LineBodyCount = 3;
createModel(LineBodyModel);

LineBodyVerticesDef[0][_X] = 5;
LineBodyVerticesDef[0][_Y] = 4;
LineBodyVerticesDef[1][_X] = 1.5;
LineBodyVerticesDef[1][_Y] = 6;
LineBodyVerticesDef[2][_X] = 1.5;
LineBodyVerticesDef[2][_Y] = 4;
LineBodyCount = 3;
createModel(LineBodyModel);


BodyShape = EDGE_SHAPE;
LineBodyVerticesDef[0][_X] = -15;
LineBodyVerticesDef[0][_Y] = 1;
LineBodyVerticesDef[1][_X] = -9;
LineBodyVerticesDef[1][_Y] = -2;
LineBodyCount = 2;
createModel(LineBodyModel);

LineBodyVerticesDef[0][_X] = 15;
LineBodyVerticesDef[0][_Y] = 1;
LineBodyVerticesDef[1][_X] = 9;
LineBodyVerticesDef[1][_Y] = -2;
createModel(LineBodyModel);

// general properties of bodies
BodyType = ZB2_DYNAMIC;
BodyFixedRotation = FALSE;
BodyPositionX = 0;
BodyPositionY = 8;
BodyScaleX = 0.5;
BodyScaleY = 0.5;
BodyScaleZ = 0.2;]]>
          </Expression>
        </ZExpression>
      </OnStart>
      <OnUpdate>
        <Timer Name="SpawnTimer" Interval="1">
          <OnTimer>
            <ZExpression>
              <Expression>
<![CDATA[xptr id;
BodyShape = floor(rnd()*4);
id = createModel(BodyModel).BodyId;

zb2SetLinearVelocity(id, random(0,3), random(5,3));
zb2SetAngularVelocity(id, random(0,5));
//zb2SetMass(id, 0.2);
zb2SetRestitution(id, 0.5);]]>
              </Expression>
            </ZExpression>
          </OnTimer>
        </Timer>
      </OnUpdate>
      <OnLeave>
        <RemoveAllModels OfType="BodyModel"/>
      </OnLeave>
    </AppState>
    <AppState Name="JointsScene" CollisionsEnabled="0">
      <OnStart>
        <ZExpression Comment="Init">
          <Expression>
<![CDATA[model m1, m2, m3, m4;

// Ladder

BodyRotation = 0;
BodyFixedRotation = TRUE;
JointType = DISTANCE_JOINT;
JointIsCollided = FALSE;
JointFrequency = 4.0;
JointDampingRatio = 0.2;
JointLength = 2.0;
JointAnchorAx = JointAnchorAy = 0;
JointAnchorBx = JointAnchorBy = 0;

// create 2 upper anchors
BodyType = ZB2_STATIC;
BodyShape = BOX_SHAPE;
BodyScaleX = BodyScaleY = BodyScaleZ = 0.3;

BodyPositionX = -9;
BodyPositionY = 7;
m1 = createModel(BodyModel);

BodyPositionX = -7;
m2 = createModel(BodyModel);

// create rungs
BodyType = ZB2_DYNAMIC;
BodyShape = CIRCLE_SHAPE;
BodyScaleX = BodyScaleY = BodyScaleZ = 0.2;

for(float i = 5; i > -7; i -= 2){
  BodyPositionY = i;

  BodyPositionX = -9;
  m3 = createModel(BodyModel);

  BodyPositionX = -7;
  m4 = createModel(BodyModel);

  JointModelA = m1;
  JointModelB = m3;
  createModel(JointModel);

  JointModelA = m3;
  JointModelB = m4;
  createModel(JointModel);

  JointModelA = m2;
  JointModelB = m4;
  createModel(JointModel);

  m1 = m3;
  m2 = m4;
}

// Chain

// anchor
BodyType = ZB2_STATIC;
BodyShape = BOX_SHAPE;
BodyScaleX = BodyScaleY = BodyScaleZ = 0.3;

BodyPositionX = 0;
BodyPositionY = 7;
m1 = createModel(BodyModel);

// links
BodyType = ZB2_DYNAMIC;
BodyFixedRotation = FALSE;
BodyScaleX = BodyScaleZ = 0.05;
BodyScaleY = 0.3;

for(float i = 6.3; i > -4; i -= 0.6){

  BodyPositionY = i;
  m2 = createModel(BodyModel);
  zb2SetMass(m2.BodyId, 0.01);

  zb2CreateRevoluteJointWorld(m1.BodyId, m2.BodyId, 0, i + 0.3, FALSE, 0, 0,
    FALSE, 0, 0, FALSE);

  m1 = m2;
}

// Rotor

// rotation middle
BodyPositionX = 8;
BodyPositionY = 2;
m1 = createModel(EmptyBodyModel);

// arm
BodyType = ZB2_DYNAMIC;
BodyShape = BOX_SHAPE;
BodyScaleX = 4;
BodyScaleY = 0.2;
BodyRotation = 0;
BodyScaleZ = 0.3;
m2 = createModel(BodyModel);

zb2CreateRevoluteJointWorld(m1.EmptyBodyId, m2.BodyId, 8, 2, FALSE, 0, 0,
    TRUE, 0.5, 100, TRUE);

// sinkers
BodyShape = CIRCLE_SHAPE;
BodyScaleX = 0.8;
BodyPositionX = 4;
BodyPositionY = -4;
m1 = createModel(BodyModel);
zb2SetMass(m1.BodyId, 0.1);

JointType = ROPE_JOINT;
JointModelA = m2;
JointModelB = m1;
JointAnchorAx = -4;
JointAnchorAy = 0;
JointAnchorBx = JointAnchorBy = 0;
JointLength = 6;
JointIsCollided = TRUE;
createModel(JointModel);

BodyPositionX = 12;
m1 = createModel(BodyModel);
zb2SetMass(m1.BodyId, 0.1);

JointAnchorAx = 4;
JointModelB = m1;
createModel(JointModel);]]>
          </Expression>
        </ZExpression>
      </OnStart>
      <OnLeave>
        <RemoveAllModels OfType="BodyModel"/>
      </OnLeave>
    </AppState>
    <AppState Name="TumblerScene" CollisionsEnabled="0">
      <Definitions>
        <Variable Name="ParticleCount" Type="1"/>
      </Definitions>
      <OnStart>
        <ZExpression Comment="Init">
          <Expression>
<![CDATA[model m1, m2;

zb2AllowCollisionDetection(FALSE);

// rotating box
BodyPositionX = 0;
BodyPositionY = 0;
m1 = createModel(EmptyBodyModel);

BodyShape = TUMBLER_SHAPE;
BodyType = ZB2_DYNAMIC;
BodyFixedRotation = FALSE;
BodyScaleZ = 1;
m2 = createModel(BodyModel);
zb2SetMass(m2.BodyId, 0.3);

zb2CreateRevoluteJoint(m1.EmptyBodyId, m2.BodyId,
0, 0, 0, 0, 0,
FALSE, 0, 0,
TRUE, 0.2, 500,
FALSE);

// properties for water particles
BodyType = ZB2_DYNAMIC;
BodyScaleX = 0.2;
BodyScaleZ = 0.01;
BodyShape = CIRCLE_SHAPE;

ParticleCount = 300;
ParticleSpawnTimer.Interval = 0.1;]]>
          </Expression>
        </ZExpression>
      </OnStart>
      <OnUpdate>
        <Timer Name="ParticleSpawnTimer" Interval="0.1">
          <OnTimer>
            <ZExpression>
              <Expression>
<![CDATA[xptr id = createModel(BodyModel).BodyId;
zb2SetMass(id, 0.01);
zb2SetFriction(id, 0.01);
zb2SetLinearDamping(id, 0.01);
zb2SetAngularDamping(id, 0.01);
zb2SetRestitution(id, 0.6);
zb2SetLinearVelocity(id, random(0,3), random(0,3));

--ParticleCount;
if(ParticleCount <= 0) ParticleSpawnTimer.Interval = 0;]]>
              </Expression>
            </ZExpression>
          </OnTimer>
        </Timer>
      </OnUpdate>
      <OnLeave>
        <RemoveAllModels OfType="BodyModel"/>
        <ZExpression>
          <Expression>
<![CDATA[zb2DestroyAllBodies();
zb2AllowCollisionDetection(TRUE);]]>
          </Expression>
        </ZExpression>
      </OnLeave>
    </AppState>
    <AppState Name="RaycastScene" CollisionsEnabled="0">
      <Definitions>
        <Variable Name="RaycastPointX"/>
        <Variable Name="RaycastPointY"/>
      </Definitions>
      <OnStart>
        <ZExpression Comment="Init">
          <Expression>
<![CDATA[zb2AllowCollisionDetection(FALSE);

// environment
BodyShape = CHAIN_SHAPE;
LineBodyIsLoop = TRUE;
LineBodyVerticesDef[0][_X] = -16;
LineBodyVerticesDef[0][_Y] = -9;
LineBodyVerticesDef[1][_X] = -16;
LineBodyVerticesDef[1][_Y] = 9;
LineBodyVerticesDef[2][_X] = 16;
LineBodyVerticesDef[2][_Y] = 9;
LineBodyVerticesDef[3][_X] = 16;
LineBodyVerticesDef[3][_Y] = -9;
LineBodyCount = 4;
createModel(LineBodyModel);

// random bodies
BodyType = ZB2_DYNAMIC;
BodyFixedRotation = FALSE;
BodyScaleX = 0.5;
BodyScaleY = 0.5;
BodyScaleZ = 0.2;

xptr id;
for(int i = 0; i < 30; ++i){
  BodyPositionX = random(0, 14);
  BodyPositionY = random(0, 7);
  BodyShape = floor(rnd()*4);
  id = createModel(BodyModel).BodyId;

  zb2SetGravityScale(id, 0);
  zb2SetLinearVelocity(id, random(0,5), random(0,5));
  zb2SetAngularVelocity(id, random(0,5));
  //zb2SetMass(id, 1);
  zb2SetRestitution(id, 1);
  zb2SetLinearDamping(id, 0);
  zb2SetAngularDamping(id, 0);
  zb2SetDensity(id, 10);
}]]>
          </Expression>
        </ZExpression>
      </OnStart>
      <OnUpdate>
        <ZExpression Comment="Raycast">
          <Expression>
<![CDATA[float x = cos(App.Time * 0.5) * 20, y = sin(App.Time * 0.5) * 20;

zb2RayCast(0, 0, x, y, RaycastPointX, RaycastPointY, UNUSED_F, UNUSED_F);

RaycastTransform.Translate.X = RaycastPointX;
RaycastTransform.Translate.Y = RaycastPointY;]]>
          </Expression>
        </ZExpression>
      </OnUpdate>
      <OnRender>
        <UseMaterial Material="DefaultMaterial"/>
        <RenderSetColor Color="1 1 0 1"/>
        <ZExpression Expression="drawLine(0, 0, RaycastPointX, RaycastPointY);"/>
        <RenderSetColor Color="1 0 0 1"/>
        <RenderTransformGroup Name="RaycastTransform" Scale="0.1 0.1 0.25" Translate="-8.6989 1.5701 0" Rotate="0 0 0.125">
          <Children>
            <RenderMesh Mesh="BoxMesh"/>
          </Children>
        </RenderTransformGroup>
      </OnRender>
      <OnLeave>
        <RemoveAllModels OfType="BodyModel"/>
        <ZExpression>
          <Expression>
<![CDATA[zb2DestroyAllBodies();
zb2AllowCollisionDetection(TRUE);]]>
          </Expression>
        </ZExpression>
      </OnLeave>
    </AppState>
  </States>
  <OnUpdate>
    <ZExpression Comment="Step simulation">
      <Expression>
<![CDATA[// step simulation
float s = clamp(App.FpsCounter/3, 3, 10);
zb2Step(App.DeltaTime, s, s);
//zb2Step(App.DeltaTime, 3, 8); // Box2D default; can cause shaking of joints

// update pointer position
PointerX = App.MousePosition.X * ScreenAspectRatio * POSITION_RATIO;
PointerY = App.MousePosition.Y * POSITION_RATIO;

// update counters
BodyCount = zb2GetBodyCount();
ContactPointCount = zb2GetContactCount();

// reset mouse pointer/touchinglags flag
IsTouched = FALSE;]]>
      </Expression>
    </ZExpression>
    <Condition Comment="Android?" Expression="return ANDROID;">
      <OnTrue>
        <ZExpression Comment="Touched?" Expression="IsTouched = touchGetCount() == 1;"/>
      </OnTrue>
      <OnFalse>
        <KeyPress Name="MouseKey" Comment="LMB?" Keys="{">
          <OnPressed>
            <ZExpression Expression="IsTouched = TRUE;"/>
          </OnPressed>
        </KeyPress>
      </OnFalse>
    </Condition>
    <ZExpression Comment="Touching post-processing">
      <Expression>
<![CDATA[// touching of buttons
if(IsTouched && PointerJoint == null){
  float x = App.MousePosition.X, y = App.MousePosition.Y;

  if(y >= 0.82 && y <= 0.96){
    if(x >= -0.22 && x <= -0.14){ // move button pressed
      IsMoveMode = TRUE;
      enableMoveButton(TRUE);
      enableDeleteButton(FALSE);
    } else if (x >= -0.12 && x <= -0.04){ // delete button pressed
      IsMoveMode = FALSE;
      enableMoveButton(FALSE);
      enableDeleteButton(TRUE);
    } else if (x >= -0.02 && x <= 0.05){ // scene 1 button pressed
      enableScene1Button(TRUE);
      enableScene2Button(FALSE);
      enableScene3Button(FALSE);
      enableScene4Button(FALSE);
      @SetAppState(State: ShapesScene);
    } else if (x >= 0.07 && x <= 0.15){ // scene 2 button pressed
      enableScene1Button(FALSE);
      enableScene2Button(TRUE);
      enableScene3Button(FALSE);
      enableScene4Button(FALSE);
      @SetAppState(State: JointsScene);
    } else if (x >= 0.17 && x <= 0.25){ // scene 3 button pressed
      enableScene1Button(FALSE);
      enableScene2Button(FALSE);
      enableScene3Button(TRUE);
      enableScene4Button(FALSE);
      @SetAppState(State: TumblerScene);
    } else if (x >= 0.27 && x <= 0.35){ // scene 4 button pressed
      enableScene1Button(FALSE);
      enableScene2Button(FALSE);
      enableScene3Button(FALSE);
      enableScene4Button(TRUE);
      @SetAppState(State: RaycastScene);
    }
  }
}

// handle pointer joint for moving objects
if(PointerJoint != null)
  if(IsTouched && IsMoveMode)
    // body is dragged by mouse
    zb2UpdateMouseJoint(PointerJoint, PointerX, PointerY);
  else {
    // release dragging
    zb2DestroyJoint(PointerJoint);
    PointerJoint = null;
    DraggedModel = null;
  }]]>
      </Expression>
    </ZExpression>
  </OnUpdate>
  <OnRender>
    <UseMaterial Material="SmoothMaterial"/>
    <RenderTransformGroup Scale="25 12 1" Translate="0 0 -5">
      <Children>
        <RenderMesh Mesh="BGMesh"/>
      </Children>
    </RenderTransformGroup>
    <UseMaterial Material="FontMaterial"/>
    <RenderSetColor Name="MoveColor" Color="0.7 0 0 1"/>
    <RenderText Text="\" X="-0.225" Y="0.895" Scale="0.8" Align="1"/>
    <RenderSetColor Name="DeleteColor" Color="0 0.25 0.5 1"/>
    <RenderText Text="\" X="-0.125" Y="0.895" Scale="0.8" Align="1"/>
    <RenderSetColor Name="Scene1Color" Color="0 0.25 0.5 1"/>
    <RenderText Text="\" X="-0.025" Y="0.895" Scale="0.8" Align="1"/>
    <RenderSetColor Name="Scene2Color" Color="0.7 0 0 1"/>
    <RenderText Text="\" X="0.075" Y="0.895" Scale="0.8" Align="1"/>
    <RenderSetColor Name="Scene3Color" Color="0 0.25 0.5 1"/>
    <RenderText Text="\" X="0.175" Y="0.895" Scale="0.8" Align="1"/>
    <RenderSetColor Name="Scene4Color" Color="0 0.25 0.5 1"/>
    <RenderText Text="\" X="0.275" Y="0.895" Scale="0.8" Align="1"/>
    <RenderSetColor Color="1 1 1 1"/>
    <RenderText Text="Bodies: " TextFloatRef="BodyCount" X="-0.98" Y="0.9" Scale="0.5" Align="1" StretchY="1.3"/>
    <RenderText Text="Contacts: " TextFloatRef="ContactPointCount" X="-0.98" Y="0.8" Scale="0.5" Align="1" StretchY="1.3"/>
    <RenderText Text="FPS: " TextFloatRef="App.FpsCounter" X="-0.98" Y="0.7" Scale="0.5" Align="1" StretchY="1.3"/>
    <RenderText Text="` ~" X="-0.21" Y="0.89" Scale="0.5" Align="1" StretchY="1.5"/>
    <RenderText Text="1 2 3 4" X="-0.005" Y="0.885" Scale="0.5" Align="1" StretchY="1.5"/>
  </OnRender>
  <OnClose>
    <ZExpression Comment="Destroy simulation world">
      <Expression>
<![CDATA[// destroy simulation world
zb2DestroyWorld();]]>
      </Expression>
    </ZExpression>
  </OnClose>
  <Content>
    <Group Comment="Artwork">
      <Children>
        <Group Comment="Materials">
          <Children>
            <Material Name="DefaultMaterial" WireframeWidth="2" Shading="1"/>
            <Material Name="SmoothMaterial" Light="0"/>
          </Children>
        </Group>
        <Group Comment="Fonts">
          <Children>
            <Bitmap Name="DroidBitmap" Width="512" Height="128">
              <Producers>
                <BitmapFromFile Comment="Imported from DroidFontSmall.bmp" Transparency="1" DataWidth="512" DataHeight="128">
                  <BitmapFile>
<![CDATA[78DAED5D3D8E5D370F1D375F61B8CC12BCB859428A54AE6705DE800B57993E75DAB42E5D05EE5205360C381F31073960245D8AA2EEEF7B3C85F1E6F9DDAB3FEA88A228F2E121914824128944229148241289442291D8169F3E7DFAEBAFBFFEF9179F3F7F7E7E7ECE6ED901E8F0DF7EFB6DF537CB3BF1F2ECE41B03A7AA7CF8E38F3F6E630AE4B01E3E0405BE7CF9923D93FC9F38F96CBDFA3C4D293D1C1F3E7C787C7CACA9630B5E4A24FF2756C1FBF7EFBF7EFD2A432CFBF7C32BF3FCFCFCF9F367D4676BFE97DF4B4169A6D80EB2AFC40633BB22F93F715A3C3D3D6194E5C35175F8E5975F40FBC40EFC4F48D152819484648FE4FF1CC13B84A8C1C76E01A468F0F0870F1FC2532066B538CFF627F93F91FC9FD81FEFDFBFC7406B13EE856478464A6F46C88D3EF4B491BF31B069C72ED55FB666F82FC35161A6F275B9C537DD864CF6BCFEF1972F5F7824E79C0EF83DCE5FA48BA0CFC8BFF2D93F9DA5938B671F5EECB19ECA4F4E5EA979E13CE66F7BD104790FCD08F242A752A7BB5DFBC30C492F345878BE8DB26EA1F4B2DB0D6518C6D525C305CD294EDF1ED6C4DFEDFF3890FC7F21FE1761FBFC2F381D7044421CC2FF9064DB4561A6F227E17F567BD43103BF14D2282CA87EC3E6D3D353F359E9D51DF87F893D86ACB254124629A8D9ED52342971A815E846E7B24BD928589A4BC9EFBFFFDEAD7953428CFFB2172FFF695D2D30F7C6FFFFFBDFFF7EFEF967F937F0BF27E4FFD5AD0AABF03F2459846DBBEDE419F81F0658D00E5532CFC2A7F9537EC9233C52BAA7EBF84BFDB8BC8D737C535111CE91C54B537DC0298506647D88D93DD06C7AA9C126EC6CBBD6D86510A196DBBC5D0CBAF473C1BAF227C4DED6B86495692AF9DC1A389721F9197E8F422981DD5DDB8A27A797E37F21F65F7FFD559E927F6B92B7FF37F9DF59222459302A63D7E27FAAD9055FD131C33E14A3E6B9A412DB1E6EB436D49DBC0FFFDB7D3234E24EE2D54CDBA459BD9BF0BF477A12D5766AD1A05CAC5C051BCB97581DBA1BB762889764C980741A4AC407FF367FC525E072FC2FBA3D25A42079923F20BF4CFE0F9448490EB8045C8BFFC100C646DE5683F1FEE66F3C6A24B5D02523F321FCBF96F130FC144D221EEB993E3CC5E7AE160D9E97CE474BF97B88BD7C8971E9EAF0ECA85F5E10E807ACF2522E1FF71F1B7109983C38BEAEFE5F2C014BDF27FF3B4B048F79CE7C6F86FFA13D367557A864B60DC728DDF338A67FB374E708AECBFF38C51E1DFDD5F9DF2FBDA82D17592C1C5DCB15CE17A4142C1FEC7F0C997C59AC0B5DFDE1AF178CBA3292C0B5C230B48D4285676E10CF5F4098E1FF70E935D5BF79F3E628F2BF19FE87243B4DDFB7C1FF977E7C45FE8723900E21B5B5B8AE32658A5DAAD39712EF87DD468B3A18586F043C0DD1FE4B010B1809BF580E9CC00A189BADF4C09F5941261D7878C8386A6A2896803FFFFCF328F2BF19FEA7EE372A84C9FFD7E57FE1CC2278A0F314F270FEC7E94921AB2034FBD805E61DE89CE47CBD16402F752E825C378794FFC272D55CCEB65B02B4BE3719836EDE81532AA02530BC041C45FE37C3FF2293F3E74AD7E27FC302730FF61F1EF4484DA41A314BF251FC0FD228E80BDD6EABE23ACA0D6D3E852DC8A905F104DF73DC6F58AE8C2F3DC08AE67F507BDB0EDD55599DFFF5C599C0ABDEBC79A3357FF92CDF3CEC0EC363FC5AFCFF30ED5A7008FF877B7E95F3DFA6063579FEEB3C039D8C2119B05A9F84FF794A554829BF5F3229D3E5529B8C84B75128756FF48C4D8CDACB8B0B81C7948D3AD4470CCD4DC1902165489997C6A299F3FBFDF0E3607EA946C0D5E46CFA7F73F431C7876C8347F13F87804BC03EFE3FE41F4E287EE3E4FF70CF53012E68E45AFE9F314FADB0C1E10CFC6F183D6C2604E1EB7559FB7C9278B1FEDAA6B0E2A2049DFF9DD3B32999CD4DCD764B0057A2B00CCCF03F675F60BD3BA1FD1F5757744FC642319FC1FF3FEC021AE07FB2B73E80C0374B5EE22BF63C4FA0EAFB5FDD0D354B979790C3F7BFFF05B292DE939A632AC189A56BC9E765D5E20A98BCCA3FEE87F0BF61E7B74367E0E5BA5CDC0293176A42AE7FE6D12E9C977F51F9E6CB9B871AA3EAF4D01270D1FBBF27F4FFE1797A2092804CBA2284C2D088F07160E806E5920CC4968000FF1746543A667BCCAADC47877B5E08531F3F05E23F344B771AD0EAE8BB433110A83EC18E5DA06BD86996EE69FE7C089A19FEEFDE5033E416BCADFF8B5A87EEAE7A9BA0C1C39DDAFAD465E0AED2DB9D74771EFFE7B4FEFFA0297D9CED8FA65547511B1A91A5206C933210580202FCFFA05CD138E34868B647B46E66ACE7D981E1F86F0FFF3DC61A3D53AB9FF5CF2CFD1BD1F97510366985C7991CA5EB503C3204F2A06DC796FE91B29A017C76E0FFEED18C71AC83FED1ADA3906B350316BCA61EBE143BCE3965662A9FFCFF70B5FBBF97C08AF5CFD463F706ACB939E2F739F733FE4FF27FF2FF3D03F6931CF1E4FF7DF8FFE152F13F93FF13B78DA1DBB289B3217C037792FFFD5176EF8A3F93FF1357949F1CF18B22F3FF9E8DF4E0FE377A0D5F0387A7FE5852C9FF89C4DDE2F1F111514FF5CDE84DF91FF9A1A4D0A3B25E9E96FF79F368E66D7072DB3A84AFDECACD38AF2612894B535F76C2BAFABF3F19D019F4FF49E7D5442291FC9F482412894422914824128944E26C5BFE30B20313894422F93F91482412C9FF8944229148FE4F2436C2F3F3B38E908C20DE67BE8C00EFFA1CB844F27F22118611ED9CF0FBCCEF0386939D4CD297480CF1F93EFCBFFF02F17910291E370366E7A9AF563D3D3D310DC479EE2E91FC8B0C4D8944F2FF3E9B97A197BF7DFB36C5E9E4726EDCAB35F2721EB25B99CCEE9D48F8E7855FEDD9C8FE138E067C06BC7AF5EADDBB773F7EFC907FE5730AD509814415469853C6DE39436D11C3E7EBD7AFB711222991FC7FABFCFFFAF5EB8F1F3FB281F259BE49B93A1B90B80D91AEEBC49DC8BB1DD3FF57311C491D7406C36EEA5B67E978A1D128E4FB66C8389D0430B0F4C4BA025908D976F91028BD99C8CF0639A79007291ADF1B895CD1638689D899443ED6752B5A3092FF67F0D34F3F49CD4562BF7DFBF6FDFB77F9573ECB37F2BDF194B00D679C4EFA8929D0ED7F4CE799ACA30FFF1ABD75124F79EDA74F9F3C89004056B1A4A59CAD3A5DA9142D2F190A7A16A09AA54CD91A81C06BF3FC4FEE6AA6020F97CE3965BCC4EE8DD1AC1081AE30DA3E74EA81C4A94316333E522C19AC92C1DE5C239A7DCBE324FF944CFEBFB4831046DC50180A45B49676A7FD8152577BB3F8A70CE533203352CF66D16C97D3B8D1849D787A9E7597F85FEA2F6CE02F7D45FE67BF616FF2F402F9407DD81ED3A5D24950B60A0AE7222140B6BD287DA84F46BB422A492D429E42DBE503BFF4BF478FA6937529874517715DB037834B0746ACCC90480C3DA257F62713C9FF67E37FDA1928A5F2412BC3CEFE97F7E839EB9F32146F117B1A4360039151E8AA4F2C48978EAC259EFAD3B28DF98EE6CB07A120DDA28D58770B279FC97782699B6BB72745DA52E9F32708A8D890EBE96857C8A0375719EA424E630EDEC31C04435A343AAAE876673A0CFCA6280EF3CBBF78C5BAAE6B804AFBFFA6661F27FFD7BF5CEA706A5C9EFEAFA58B1E23F694E1CCF22C55C6845D222BBBFEDC59CF3B34C65817955CF7507586FFA9FC372D2DEC2E63596C96CED7CEAC7481291923B1E602072677F21B697FC8898B670DDA8C83AE932F51375B5430407A32727EED603A6BAE3EC9FF5BE3F5EBD775772DF1BFFCB2380EC6A8D5578D9C3D605C08F24C192827612F4763C2D2A6D42D7D95DB4C317EC3848DAD7D5BF03FED51F6CB8D8B69CDD2BBC7BE27E17FA375DD9EA9359F5F5EE0543040D422CF247C5D2EAE5D7BCC5FF8191F0FABE50129E25A13B35B26FF07F0EAD5AB8F1F3FD6336B89FFE597F27BED144A9E2C348421FE6F8E1744D7DE7862F50913E0D2E2E5ACFF2A1ACB24EBD6BE2E7E8F91D5F9DF584F9D6B7A5D3A07628616628B488C4CECC36BE71ACA7AA2DADDABDCA07D746CFD382BD0950D92B0EC14B8ED0AF47C4C8A50C9515B53F27F18EFDEBD934A7EFBF6ED8FFFE2EFBFFF96EFE5DFE27BF9A57C2F4F2D5110EF1A0FD97FC25366D22CB04AE9ABDCB98B3584FE4EECF6F96B56CD56C80B3D75EB7A09D28CEFEC071E3ECE6CB2E80DBBE921E65AFC5F10BE470BE2FBA108615BFAF802761D7EE0690B343A4EE18072C54524B071983C08B81CFFA3BD86790D7BFC2DA237BC7DFBF6C78F1FF2F2EFDFBF3BDB8B5FCA53C5ED60FA5DD7BE34C9FF1BF13FE6A93E79076186A76DB7515D8FACAE79C769205AC591157347BB048FF6C9FEFC4FE6643FD30464F7003A1645E354EBF905D4F94123CE6594B338A68A6B8530B07798D9565F8EFF69B8B37B63A38B93ABE8FF333D3069FF99E4BA49FB8FB1371FDD0086CFCBEA1DFDE426BAAE895090D389B1DB8A6EB718734DE6887316E02E897E56466A87AB10F3FCCF357D54C841B91006AAFDDC087878A6B94C074208A2209113BC24B0159D3908B8A2FDC7389AC17BB60BE4386FFF5F85FF9BB2ED3FFF0D739D61AFA65B69B774E3F878A3FB92FA915A6C26233F2CD584AF352AB996FEAF8B10FA12DDD5EF0FCC1FF3365FF8E0607FFE6F2A247E45882DFD4B41EF239C33455F5E8ECD2974029A33EA3B34A3C35C91FFF5D94DA1C64C9E867830E9FF636B32DDCADF86FF67CD304BCAF98AFCBFB4FB280E10579C410C3A6A3FBBA2FDBF96077BA0290F52C4E439F8FEFCCFF3D63AA047D709B39043AEB3BABB9C8C44EE8580C57C78B0E9980942183B08B8E8F92FBABAD8DE42BD9C17E32E66FCFF1FFECD4222C2C9FA9357BBF646CED6F0FD2FEEF48BFB5FF2D9A3FB2DDDFF721AF049689C9B52341E1F5AB803FCCF79AAE9827901B63813E9FAC46EE1FF53BCDC2613EE0757B197EECCFFC676D2BEBCC653F27A29D1562F8F2B295F25F2CC1853FECEC41869DE989146C33C7B63FC5F3B7263253D2A7EAFFFFEEF83F242090470A092DF0CC2E0DCB91BF11FBA0B5033910AB447E708369BEF6FFBCCD9318B960FBC2ECA6F9CE18FFC33A86BBDE92E1031FF7FFF9C5A37F1CDCEFC6F6C78EDC79D163FCF15806205C79FCE53E342F99FB4E4E817FACF6EAEEBFF596C019CF735CEC0FF0F0B01D03C6A03C7B78EFF3674A9B68EFFE627C066E839DA769C762416ED6FBBF6D80CFB0E493D8D97AC7B73A7BBAFD9E8FEAF9E119BFA831DC8FFEC9CA6E468B57CC98CD91D6B7D466C0F1F0788E57A8868C96233B305E0F2E1DC835C97FFF516603B9FCFAE212810FF73CF29B61B76BEC1719E7EE89EFFDA5A8111FFC77303AB6BFFB7755114B1D6C4D993FF9DA6B3E60FF0F26EABB58FA8D17BC5F83A8F930CA71DB63D6694EBF6CC6DF03FFA1F2B5DF338601FEC1CFF3FF9FFFCFC2F335A071AB555411DFF137138872270D6F7BF7408CDEEE3B4DAE1308871237118A48F699A0C5680EB9D330A6598FFA9661BCA399B56D3020E0EBAC2632F1386A6ED51E06D96B65D58ED989F94288F59EFD2FC0FB5DF79E37B3BEC99FF2BF9FF9CFC3F1342DF8881DF7D7CBE743B2742D7796966D687F9DFE076CF1AA15D2EBB8B6393FFED20CF8C0BB754BD6E98383B52E2EAF1FFAF9BFF97DBE7C379609FFCBFC9FF7A77BF6E24B715F97F3485569D036BE83C68B2F46632204446325E7220FF3BA3832E99809C267AE398B8EB5B85A2978C6F1ED72CC33497FC5FC8C90E3E9F2741F27FA1B5D2D501F15B1E1289C441BBDDB5A2BB2492FFBBA8DD5057892C9D482492FF93FF4FCEFFB5CD24F93F9148FE4F24128944F27F229148241289442291482412894422914824128944229148241289C49DE0EB0BB21F128944E2DE80880481F40789442291B83490C0222FD08DE2F1F111E9FC74E8A45822A14422913804FB5FDFBE01E8347C9FFF05C3E89DF0927E2291D8024F4F4FA2F515013C9D19D9F8542074A70662E2C502A133A2F21D2AAEB17EC38E692946F78717341FB44383124676E387E57BB8FEC8B1BAAAA3FB973A5079375AACB3FECE9BC2ABACB0450019B442C4C09EB693494BBB6DEF26EC904A52EB409D87E6ACDD75DD9C5393C17E3561D621DC3D6F68F60F3BA4DB7C19DC58A4E52E158423F0371F0CD0F8CC2D7B0EC71D9A8002FDC654EF4349578BA5D653ABA5C8C6DD69E8113CA9BCD63D568902EDE4E4C3F95FFAA70E20E96FFB0CFFD75B45D038E0597D9A793A9CA2E8C957DECDD934CFFFEC2B2DA831FEE7ABBA3D3F9369A5FB4E614E0E81F00375AA6E326EBDFA6079F2248EDC88FFBB890B6F0FCC64ED7F04B419CB366EE7262E846A493369CE62A98F3649D9D593376BE395CEFE26AFB5D347EAD291724EA8836FF3C8ED52AAB86ECEB855F89FD951A5CEF212163A99323B60441D6D888C8BAEB0700BE9C23973BBF96A6DCD333C7045CFB0ABB5B4C4F85FAFE35D9D8D6C5F675A0CE872F6767E29C1B77F4D195A9566EC3F1BD9C4364DC92D2F8F31702D18F2AAEE325D0812E556EAC05D335EC2BC844B12D53501D9C61F9B379CA99F3901032CBAF420AAED49C83249E0938FA3EDF5F6CD43E0C7F2BF4D179EF72CFD1232DC4D1B3D2933FA4FF0B65EB602FC8FB67327D5D5D99A7B76D42446560651735CC246E98B6AE34E556A15BBCD5AABC0A8B90F544F2D5A24100286D501A9C997F614B67AEFD920D8D390FCD655806764BE593A666277337520FFB3EDF5E317E5FF875E3AE96E89B4FC7475E055F81F7B0DD116506DCE8200FF33FBB3FD2C957F9BA8035B00C3C8C34267AC047EBDF40CD0FB29F9B0E969F29E65D5734DAF05DC0B80F621D2187DDB802F725BEFA0BBC2DC9D865D22E20F627B5EA3747BA29D81FF8DEEBD2EFFFB8BAE4BA4E56766FB30C4FFA8ADFC8BB1A0A88CF23F6A2E93CE48D5DA1DF4623E8EB60B7BDEA6CD13FF15B68140953A8F3DC7CFC64E9D7C9588F17AAF115B05208DFE61D2152B0E028AB35DC3084353C9126CEB8D3D0DF1724309EF6E106648002BE04CFD37A54D4355BE4FFE775A7E56E47FC827CE2F34C58DF23F8652265D97FFBBFB23674AF126FF34151E8E888709A51F4808321CE85EE8969B9AD08F62FE15F97F7E15A0B9DE5F6D0E4A61C629E4D078ED922B82D381C763FF3734871983A7D3FAE43F410E5720767CDC6C3B9EE259EACDF33F65C36FF95991FF3104B472505486F81F720E1DA6CBFF5D819FD1883897D1AB9A8B3C44D4741F953E39FF118066FE7937DA7968EFA9A15500E2E174B832F89F563BAD54D8851606A221EF50C3FFC743BFA30E664E12F0B3E81281CF6B0E7E02D4ECE17FBC59734FC34FC2FF6CC26805E6F91FBC4DF9048104F81FBD8D9A74F9BFAB11798CAE4EFD93FCE39164D65C4F46B894F82F351C05E7A5959DA1A7B37FE1206D7A8EC0A827D48EA0BA5C7D52B0C493055163C9E832B3417D9E0B419B9A5FFC5694F0A66F9EFF9B06F0C9BB0F0107ECA3F85FFB4C3A2D3F6BF13F341C5231EC1E38E5F4F33F152DA85E4EFE37AA3D1F00A1B0E83A2F52196704A3FC3FE9FF1978FC66F47F4894D325526BF5284E779A96525BFFE75169BD7DE81EFA4FDEFF3D89FE3FC9FF31DA5CA5ED57E77F5CF108F800CCF33F188F73532F077EFE477BB50FF6B1FA3FDDDEA45DD29FF8D3B3B082E4EDEB78A3923929D8F766FF2FDAD2B5054180316B2078DAA9584B69D7A258988030173C46C8E634943AF0E4D75E02305E9BDAFFED561C78FEBB5DDB2F77FE3B64F65C8BFFE920A7CDF8180E3FFFE3259C744EFEDFC8FE8FCE2F261DC4ACDB5186FD84AF3D39FF87578193F8FF2CD98296C60E2C4DD2C6328D2BFCD4A9A45650E66D9EC1B3D4139CC61F7B1A6214ECED27F7AA5BD0AFE770F970FF9FF0B1DA2DF13F45DDBF044CF23F2645C169ACB993FF3101B5801DE8FFC319D73CC8EB8A99714C0C72F057697FFB8FBD0A5CD7FFDF3E79870CEBFF95A2C9FCB4C014CBC4D25AC37941E38F7FE96C4E438FF96532DC9F513A67A2DDF003F97FBBBB0F57F4FF1C0D3530C9FF28AE504E40CE4E1D9ED7EDEB8B00DDB3B62DFCFF9774F86E95F4BAD32CD7B9833821AE7EFFB73B9B204E36C561F8BAA6782A0F4E856115FEA7961E53838DD239EE76C30FE47FAEB3B12380DBF3FF1F520626F95F3BED1495EF36817A452DB75DB275DEFF8D3109A652C1E1340B7854CDFA671C94C30F55275781EDDEBF5DE487EEFD29847D30E27F16F782BB3357D40030A75303E9DA7FBAC4CEE91688F8BA543A971EA7D9F3A8F83FAC67CD06CEA3F35BE2FF0715CC7CD3F80F22E1CDC0892067C6B5EEEA7BF5C079946D23FE8F73CAD8E2246FD607797EC31A3D0F195286A37995CBBF57045D08100C103DAF2FE2D9420E9D410F3A09A41BBDADA98E4E5EC341E587A2BAE973135CA264000ADB9E561401932C6D71FE283493F13FC38F3F28E73AFD1244310DEF5CAECBFF0FCB31F156E47F4AC8D26B6D7F391DAE79C9EA685440C7FFA4B46B1BF28C3249F36F7187CBF32C4F610A845DD412E1211BEA7C91A822FF17DF39E453ADCF0E8678C38806EF7C0F7DCC9AAEA481D287F62F93F1FF67DC06E8A437DA8463E3FF6FC7FF94C38D2E6EEBFB294BCAB9C7FE6307AFB6EBB045FC7F3D047AFA0F7551918A6834A74F2206844F2FB25F4121F4BFA4C8FF1B183BDAFABA61936D028CA51EC6C5554D86DD24744BD7D577CEFF35EF365C8FDD4CE4EA1DF27F6DCAFF3A98ED76FCDF5C5E750C04FB0D4DABAC93FF6BA65D25FF57229148241289442291482412894422914824128944229148241289442291482412894422914824128944229148241289D382713CFC377019442876EBFF0C0867CD48241289BB25FFDB58029AF1181389C41D6226B3DEA51148A547307EEC151B8E60A78120D2894422F9FF06000E0CC70F7F984B3F772C02418F1389C4D2541A0A1DBC8AE25A689E76168615F9BF693A6012736895B655E4F9F95907D195DF337C2243026E1D469B05CDC40FE74B9003E242984C2539092914023C54BA91746FA8E1E178BFC594F10BCF64CA6C994DD26A1DF214A1A7FD81670DD1EDFEB22E3D16B1567EAF53570C05F0C483E754B42663C0C6800ED11DC8749C9EC7114259470F060F7BC61492A3D56646A0FDE305B6615C0B928694EE8964BB16D652DDBB29AACF094EFF434C40CCBF30643DE399CBE46085D32E1CC5FFC653E113283FFFAF92B142478A0E547E32D5E33EC2BC67DD90014497886D885325981CD3620B50E4D5856ED924169A1D98378DF99BB4546C1DD99B09DCE7B55F4AE6B50E8239FD67CC5F3BF33F1F8C8D1A65AF10D4D89E6268CA93FD74BE367FEE3369B5BC41E60B654C3E3059616CBEF8F99FA5B314295D3AD3AFAA315D913C8597C8DBA080F92B8FE0FF27CCAE85E4833B277C87E8EA4241444E49C698CA2390288C2325AADB16643F2475D4A6A7A5A98D41AF39879AFF3EB69475ADDF6B6503BC1FC4EC3F24D2D8AEAD29DB61491855F9FCB97A87D498AE03C3D272C3B50F7F066A4525CAD6399929B5FE5933037B57D1CAB42F5CBEF5B8E39BD8D4E08358A93D3AA1D6F9EB1964270CAD475CA778DB8148D735271E659CBCC3035C72CE280950C096BA71D4961ED8F23357EF8A0CD67542FBC78798F4E2C8CF7E162B6C9352C0367E2392533BBD6DE824A43A0329A58B7F06F87F28231B05CFAFFF37199E931A5BBC1D3C2AD7DD4B620EEE6F483984FFC3A9DBD742EC14D8D83860E28C9E83C44CBE9E5CBDEBEE6437E57FCFEE09DDDB1C2F6351368A3B9BC735E86BB755E91F37C2FABFB38731A7A4E150033CF6FFA6FC6B43E28C81F7288BCD51BE9407163A236CF3B6A30009182C04991F25C0F091DFBA4B4077C2E207F564F46B7A93926F28EDA375A029E954F716D18AFD7725932E4035FFCB8343F7A1B805D00FDA764EAEF85C2CB86DC1EFF7B99794FC7F5DFE8F2909F3F9DFD7E2FF42E159A52BEC098BDF14C76AABF0BFE70AA471C21ED0E78FDA6B77F97FD22D39DCF9B50B5060710CBBC341BB9072FDFEFFF485909FF13385739F2D5EF2FFA51138053E15FF7BCE6DBB9C436F8DEE8495C955CFA979FEA7D9D66E85E1E815B0BCB1D0F33882CE1CBCCED34EED02E4A735A979E1971B10C8FA269A670BAF1D3EF75F3A0FB7FFCB18E9564B8778AEC3AC6BF4BB2E6807F01FA49E8AFFC9C9B15D8C56D59C931DBA59ED2EE26C7571C4A37DB6BBC7D9E47F9920FA25649ED13E8C9DD7DC1EFF4FBA00D12997B2E4994DB59E8FE933CAE1143F30E7CECEF3C7FAFFF016123BDC79F09DFC5FF4A17F053F1BFF3F0C9EB535F7E9436B07E8BABE68EF7C307CFB0CB22D8DD5B74D67743FD6FC248EA038EEDC93FFE75D8028F3E07067FD9BF77C69FC1F1A0E5DF9FDCF74E8FCBCA21DC6EF40C86E84F087EF36DE73009FD153E013F2FFC3844323EF4FF9ADB5D87170973ACAFF52905E08FCD127F44A2D028FE500CC13BEE973AABB60909F00FFE341B6A2F873520FB407B7E84067FD97EEF9FA6BAE272FA70F7782815DC068D1850161C5FBBF43CB9F36C9622C02B15CEE3C80DBD029F079FC7FEA09153E08A66A3DB469C2EFFDFC3F192A7CD4C97F8BD57F07FE0F1C49170B47601D09BB0015D2EB2CD7F0F31FDA02D4B177C236BDF0E2BB960928FC1ECE8BB031F3CEF97F88588C9B4A4E5392C8B6FC9212BE0AFF4F7A0E8C5A90B8F114456B94FFC3CE123CE958D75C8386CC44C05B97FF038358C8A4E7325DF30DB50B507763556C3C9DE51AF77CB1223BF5F07A33BE561F06AC88ABC4FF74BE04F34EF0DB0BB41554FE1CBD4B75E7FCCF4D9C67DB6858FC9C3BC1C251F90CFC1F781CFD208BA69FFF31C5669CE5B630D784B5EEF3F07F113A321049B28EF9E674012A2232914211CB28A0FF73943DABFC8AFC3F137E733EFE3F9AECD7DE7974BE4A4CC50CE0EF3F055E8A42E3F73716DAA7ED3A7064D3F4EFF2DBF09BCB1397A458A739E527BCC52E4869F533BEE6BD86A38430CC5D7C30F01EECADB401B0760AEA965E63695765DFF3C5287BE404EFC1D931EA8CA10C9841C29D3FAF99C4DC3E31DF65C8A0EAA33FE146351A927AE7C00B27C4901D983A4F1DFFD3AFDC16B3C6D9FF34D4E0A6CCC37FFDE8BAACC8130AF9251611FDF8A8660E2B100F73FD423B13FA83CB8DB4428712ED3EFEB48C932405085310D589E69F7EFB43D103FE3E11711229D2C7FAA0A6251D5EDF5B69DEF34513BA63CAF714089CFF063AAD5993514322A863349CE3E30B8A9714F337C31B069440A762D974411C5DFDB5E3B47FFD5D52B73CA50B612E3961C676BEDAF6E8379D4DBA1C170EE7CEC7CFEFF35CBB730FEDDF59FF58736AFD277021CBBF64D8F77CFD5B00BC8752DD4D19E6ECC39925C0BF395D2BF97BCC792951B38A9F06B9CF0AB8D06B0128DCE99DDA9A9679E8F3432A875E4426F37FB1139C4AE62AF42B0C59A712BB3AFFDF00EE36FFFBB19889669F48241289EBE2A2B923138944229148241289442291383FFE0F90F6D969]]>
                  </BitmapFile>
                </BitmapFromFile>
              </Producers>
            </Bitmap>
            <Font Name="DroidFont" Bitmap="DroidBitmap" FirstChar="32" CharPixelWidth="21" CharPixelHeight="32"/>
            <Material Name="FontMaterial" Shading="1" Light="0" Blend="1" ZBuffer="0" Font="DroidFont"/>
          </Children>
        </Group>
        <Group Comment="Meshes">
          <Children>
            <Mesh Name="BoxMesh">
              <Producers>
                <MeshBox/>
              </Producers>
            </Mesh>
            <Mesh Name="CircleMesh">
              <Producers>
                <MeshSphere Name="OrigSphere" ZSamples="6" RadialSamples="8"/>
                <MeshExpression>
                  <Expression>
<![CDATA[//V : current vertex
//VarP is set to the number of Z samples;
//VarQ is the number of circonferences wanted in the upper and lower faces
float VarP;
int VarQ = 1;
float Psi;

VarP = OrigSphere.ZSamples;
if (v.Y != 0 || v.X != 0) {
    Psi = atan2(v.Y,v.X);
    v.X = cos(Psi); //*pow(1-abs(v.Z),2);
    v.Y = sin(Psi);
    //Normals
    //n.X = cos(Psi);
    //n.Y = sin(Psi);

    if (VarQ == 0) {
        v.Z /= 1 - 2/(VarP-1);
        }
    else { //VarQ != 0
        v.Z /= 1 - (VarQ+1)*2/(VarP-1);
        if (abs(v.Z)>1.001) {   //this is because we are using floating point precision
                                     //it is better to avoid stuff like "Z > 1" due to truncament errors

            //remember: tallest's high: (1/(1 - (VarQ+1)*2/(VarP-1));
            v.X *= 1 - (abs(v.Z)-1)/(1/(1 - (VarQ+1)*2/(VarP-1))-1);
            v.Y *= 1 - (abs(v.Z)-1)/(1/(1 - (VarQ+1)*2/(VarP-1))-1);

            v.Z = v.Z/(abs(v.Z));

        }
    } //ELSE

    //Normals
    if (abs(v.Z) < 0.999) {
        n.Z = 0; //lateral surface
        }
    else {
        if (pow(v.X,2) + pow(v.Y,2) < 0.999) {
               n.X = 0;  //Upper surface
               n.Y = 0;
               }
        else {
                 //Edges normals, you can decide what to use.
        }
    }  // End of normals section

    //soft edges      Work In Progress
    /*
    if (abs(v.Z) > 0.7 && pow(v.X,2) + pow(v.Y,2) > 0.7) {
        v.Z *= 0.9;
        v.Y *= 0.9;
        v.X *= 0.9;
        }
    // */

} //OUTER IF]]>
                  </Expression>
                </MeshExpression>
              </Producers>
            </Mesh>
            <Mesh Name="HouseMesh">
              <Producers>
                <MeshBox Scale="0.5 0.5 1" XCount="1"/>
                <MeshExpression>
                  <Expression>
<![CDATA[//V : current vertex
//N : current normal (turn off AutoNormals when modifying normals)
//C : current color (turn on VertexColors)
//TexCoord : current texture coordinate (turn on HasTexCoords)

if(v.X == 0 && v.Y > 0) v.Y = 1;]]>
                  </Expression>
                </MeshExpression>
              </Producers>
            </Mesh>
            <Array Name="HousePoints" Dimensions="1" SizeDim1="5" SizeDim2="2" Persistent="255">
              <Values>
<![CDATA[78DA636060D8CF00C1F64834080341035C0C0062B704B8]]>
              </Values>
            </Array>
            <Mesh Name="CompoundMesh">
              <Producers>
                <MeshLoop Count="3" Position="1 1 0">
                  <OnIteration>
                    <MeshBox/>
                  </OnIteration>
                </MeshLoop>
              </Producers>
            </Mesh>
            <Mesh Name="TumblerMesh">
              <Producers>
                <MeshBox/>
                <MeshTransform Scale="6 0.3 0.3" Position="0 -6 0"/>
                <MeshBox/>
                <MeshTransform Scale="6 0.3 0.3" Position="0 6 0"/>
                <MeshBox/>
                <MeshTransform Scale="0.3 6 0.3" Position="6 0 0"/>
                <MeshBox/>
                <MeshTransform Scale="0.3 6 0.3" Position="-6 0 0"/>
                <MeshCombine/>
                <MeshCombine/>
                <MeshCombine/>
              </Producers>
            </Mesh>
            <Mesh Name="BGMesh">
              <Producers>
                <MeshBox Grid2DOnly="255"/>
                <MeshExpression VertexColors="255">
                  <Expression>
<![CDATA[c.R = 0.0;
c.G = (v.Y)/6 + 0.2;
c.B = (v.Y)/5 + 0.5;]]>
                  </Expression>
                </MeshExpression>
              </Producers>
            </Mesh>
          </Children>
        </Group>
      </Children>
    </Group>
    <Model Name="EmptyBodyModel" Category="1">
      <Definitions>
        <Variable Name="EmptyBodyId" Type="9"/>
      </Definitions>
      <OnSpawn>
        <ZExpression Comment="Create body" Expression="EmptyBodyId = zb2CreateEmptyBody(BodyPositionX, BodyPositionY, ZB2_STATIC);"/>
      </OnSpawn>
      <OnRemove>
        <ZExpression Comment="Destroy body" Expression="zb2DestroyBody(EmptyBodyId);"/>
      </OnRemove>
    </Model>
    <Model Name="BodyModel" Category="1">
      <Definitions>
        <Variable Name="BodyId" Type="9"/>
        <Variable Name="BodyType" Type="1"/>
      </Definitions>
      <States>
        <ModelState Name="DynamicBodyModelState">
          <OnUpdate>
            <ZExpression Comment="Update Position &amp; Angle">
              <Expression>
<![CDATA[// update transformation
zb2GetTransform(BodyId,
  CurrentModel.Position.X,
  CurrentModel.Position.Y,
  CurrentModel.Rotation.Z
);

// remove model if out of the scene
if(CurrentModel.Position.Y < -12) removeBody(CurrentModel);

// collisions
//BodyColor.Color.R = 1 - zb2IsCollided(BodyId);

// awake?
//BodyColor.Color.B = 1 - zb2IsAwake(BodyId)*0.5;]]>
              </Expression>
            </ZExpression>
          </OnUpdate>
        </ModelState>
      </States>
      <OnSpawn>
        <ZExpression Comment="Create body">
          <Expression>
<![CDATA[switch(BodyShape){

  case BOX_SHAPE:
    BodyId = zb2CreateBox(BodyPositionX, BodyPositionY,
              BodyScaleX, BodyScaleY,
              BodyRotation, BodyType);
    BodyMesh.Mesh = BoxMesh;
    CurrentModel.Scale.X = BodyScaleX;
    CurrentModel.Scale.Y = BodyScaleY;
    break;

  case CIRCLE_SHAPE:
    BodyId = zb2CreateCircle(BodyPositionX, BodyPositionY,
          BodyScaleX, BodyType);
    BodyMesh.Mesh = CircleMesh;
    CurrentModel.Scale.X = BodyScaleX;
    CurrentModel.Scale.Y = BodyScaleX;
    break;

  case HOUSE_SHAPE:
    BodyId = zb2CreatePolygon(BodyPositionX, BodyPositionY,
          HousePoints, 5, BodyRotation, BodyType);
    BodyMesh.Mesh = HouseMesh;
    CurrentModel.Scale.X = 1.0;
    CurrentModel.Scale.Y = 1.0;
    break;

  case COMPOUND_SHAPE:
    BodyId = zb2CreateEmptyBody(BodyPositionX, BodyPositionY, BodyType);
    zb2AddBox(BodyId, 0, 0, BodyScaleX, BodyScaleY, 0);
    zb2AddBox(BodyId, BodyScaleX, BodyScaleY, BodyScaleX, BodyScaleY, 0);
    zb2AddBox(BodyId, BodyScaleX*2, BodyScaleY*2, BodyScaleX, BodyScaleY, 0);
    BodyMesh.Mesh = CompoundMesh;
    CurrentModel.Scale.X = BodyScaleX;
    CurrentModel.Scale.Y = BodyScaleY;
    break;

  case TUMBLER_SHAPE:
    BodyId = zb2CreateEmptyBody(BodyPositionX, BodyPositionY, BodyType);
    zb2AddBox(BodyId, -6, 0, 0.3, 6, 0);
    zb2AddBox(BodyId, 6, 0, 0.3, 6, 0);
    zb2AddBox(BodyId, 0, 6, 6, 0.3, 0);
    zb2AddBox(BodyId, 0, -6, 6, 0.3, 0);
    BodyMesh.Mesh = TumblerMesh;
    CurrentModel.Scale.X = 1.0;
    CurrentModel.Scale.Y = 1.0;
}

// set model scale
CurrentModel.Scale.Z = BodyScaleZ;

if(BodyType == ZB2_STATIC){
  CurrentModel.Position.X = BodyPositionX;
  CurrentModel.Position.Y = BodyPositionY;
  CurrentModel.Rotation.Z = BodyRotation;
} else {
  zb2SetFixedRotation(BodyId, BodyFixedRotation);
  @SetModelState(State: DynamicBodyModelState);
}]]>
          </Expression>
        </ZExpression>
      </OnSpawn>
      <OnUpdate>
        <ZExpression Comment="Select, drag, delete">
          <Expression>
<![CDATA[// under pointer?
// pointer over?
if(zb2TestPoint(BodyId, PointerX, PointerY)){

  // set mouse joint for the current body if dragged
  if(IsMoveMode && IsTouched && PointerJoint == null){
    PointerJoint = zb2CreateMouseJoint(BodyId, PointerX, PointerY,
                    1000.0 * zb2GetMass(BodyId), 5.0, 0.7);
    DraggedModel = CurrentModel;
  }

  // remove body?
  if(!IsMoveMode && IsTouched) removeBody(CurrentModel);

  // set color
  BodyColor.Color.R = 0;
} else
  BodyColor.Color.R = (CurrentModel != DraggedModel);]]>
          </Expression>
        </ZExpression>
      </OnUpdate>
      <OnRender>
        <UseMaterial Material="DefaultMaterial"/>
        <RenderSetColor Name="BodyColor" Color="1 1 1 1"/>
        <RenderMesh Name="BodyMesh" Mesh="BoxMesh"/>
      </OnRender>
      <OnRemove>
        <ZExpression Comment="Destroy body" Expression="zb2DestroyBody(BodyId);"/>
      </OnRemove>
    </Model>
    <Model Name="LineBodyModel" Comment="Static body based on lines" Category="1">
      <Definitions>
        <Variable Name="LineBodyId" Type="9"/>
        <Array Name="LineBodyVertices" Type="6" SizeDim1="10"/>
        <Variable Name="LineBodyCount" Type="1"/>
        <Variable Name="LineBodyIsLoop" Type="1"/>
      </Definitions>
      <OnSpawn>
        <ZExpression Comment="Create body">
          <Expression>
<![CDATA[// copy vertices to local array
LineBodyVertices.SizeDim1 = LineBodyCount;
for(int i = 0; i < LineBodyCount; ++i)
  LineBodyVertices[i] = LineBodyVerticesDef[i];

switch(BodyShape){
  case EDGE_SHAPE:
    LineBodyId = zb2CreateEdge(LineBodyVertices[0][_X], LineBodyVertices[0][_Y],
              LineBodyVertices[1][_X], LineBodyVertices[1][_Y]);
    break;

  case CHAIN_SHAPE:
    LineBodyId = zb2CreateChain(LineBodyVertices, LineBodyCount, LineBodyIsLoop);
}]]>
          </Expression>
        </ZExpression>
      </OnSpawn>
      <OnRender>
        <UseMaterial Material="DefaultMaterial"/>
        <ZExpression>
          <Expression>
<![CDATA[float x1, x2, y1, y2;

x1 = LineBodyVertices[0][_X];
y1 = LineBodyVertices[0][_Y];

for(int i = 1; i < LineBodyCount; ++i){
  x2 = LineBodyVertices[i][_X];
  y2 = LineBodyVertices[i][_Y];
  drawLine(x1, y1, x2, y2);
  x1 = x2;
  y1 = y2;
}

if(LineBodyIsLoop)
  drawLine(x1, y1, LineBodyVertices[0][_X], LineBodyVertices[0][_Y]);]]>
          </Expression>
        </ZExpression>
      </OnRender>
      <OnRemove>
        <ZExpression Comment="Destroy body" Expression="zb2DestroyBody(LineBodyId);"/>
      </OnRemove>
    </Model>
    <Model Name="JointModel" Category="1">
      <Definitions>
        <Variable Name="JointId" Type="9"/>
        <Variable Name="JointModelA" Type="3"/>
        <Variable Name="JointModelB" Type="3"/>
        <Variable Name="JointAnchorAx"/>
        <Variable Name="JointAnchorAy"/>
        <Variable Name="JointAnchorBx"/>
        <Variable Name="JointAnchorBy"/>
        <Variable Name="IsRemoved" Type="1"/>
      </Definitions>
      <OnSpawn>
        <ZExpression>
          <Expression>
<![CDATA[xptr j;

switch(JointType){

  case DISTANCE_JOINT:
    j = zb2CreateDistanceJoint(JointModelA.BodyId, JointModelB.BodyId,
        JointAnchorAx, JointAnchorAy, JointAnchorBx, JointAnchorBy,
        JointLength, JointFrequency, JointDampingRatio, JointIsCollided);
    break;

  case ROPE_JOINT:
    j = zb2CreateRopeJoint(JointModelA.BodyId, JointModelB.BodyId,
        JointAnchorAx, JointAnchorAy, JointAnchorBx, JointAnchorBy,
        JointLength, JointIsCollided);
}

zb2SetUserModelToJoint(j, CurrentModel);

isRemoved = FALSE;]]>
          </Expression>
        </ZExpression>
      </OnSpawn>
      <OnUpdate>
        <ZExpression Expression="if(IsRemoved) @RemoveModel();"/>
      </OnUpdate>
      <OnRender>
        <UseMaterial Material="DefaultMaterial"/>
        <RenderSetColor Color="0.502 1 0.502 1"/>
        <ZExpression>
          <Expression>
<![CDATA[float
  a = JointModelA.Rotation.Z*PI2,
  b = JointModelB.Rotation.Z*PI2,
  sa = sin(a),
  ca = cos(a),
  sb = sin(b),
  cb = cos(b);

drawLine(
  JointModelA.Position.X + JointAnchorAx * ca - JointAnchorAy * sa,
  JointModelA.Position.Y + JointAnchorAx * sa + JointAnchorAy * ca,
  JointModelB.Position.X + JointAnchorBx * cb - JointAnchorBy * sb,
  JointModelB.Position.Y + JointAnchorBx * sb + JointAnchorBy * cb
);]]>
          </Expression>
        </ZExpression>
      </OnRender>
      <OnRemove>
        <ZExpression Comment="Destroy joint">
          <Expression>
<![CDATA[// in the current application joint is destroyed
// only together with body => it is not necessary to
// destroy it explicitly

//zb2DestroyJoint(JointId);]]>
          </Expression>
        </ZExpression>
      </OnRemove>
    </Model>
    <Model Name="VisualizeCollisionModel">
      <OnRender>
        <UseMaterial Material="DefaultMaterial"/>
        <RenderSetColor Color="1 0 0 1"/>
        <ZExpression Comment="Render contact points">
          <Expression>
<![CDATA[int s;
float x, y;

zb2ResetContacts();

for(; zb2GetNextContact(UNUSET_PTR, UNUSET_PTR, x, y, UNUSED_F, UNUSED_F, s);)
  if(s == ZB2_ADD_STATE || s == ZB2_PERSIST_STATE){
    ContactTransform.Translate.X = x;
    ContactTransform.Translate.Y = y;
    @CallComponent(Component: ContactTransform);
  }]]>
          </Expression>
        </ZExpression>
      </OnRender>
    </Model>
    <Variable Name="BodyCount"/>
    <Variable Name="ContactPointCount"/>
    <Group Comment="Repeated model parts">
      <Children>
        <RenderTransformGroup Name="LineTransform" Comment="Component for drawing lines" Scale="6 0.05 1" Translate="11.807 -1.3307 0" Rotate="0 0 -0.2595">
          <Children>
            <RenderSprite/>
          </Children>
        </RenderTransformGroup>
        <RenderTransformGroup Name="ContactTransform" Scale="0.1 0.1 0.4" Translate="9.9257 2.0316 0" Rotate="0 0 0.125">
          <Children>
            <RenderMesh Mesh="BoxMesh"/>
          </Children>
        </RenderTransformGroup>
      </Children>
    </Group>
  </Content>
</ZApplication>
